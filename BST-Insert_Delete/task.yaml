accessible: true
author: Alexandre Gobeaux
context: |-
    To help you study your english course, you've got the wonderful idea of creating a Binary Search Tree (BST). This will also help you to study for the LSINF1252 course! The key of each node will be the english word and the value will be the french word corresponding. Those are represented using an array of char.
    So let's define our 2 structures :

    .. code-block:: c

        typedef struct bt {
            struct node* root;
        } bt_t;

        typedef struct node {
            char* enWord;
            char* frWord;
            struct node* left;
            struct node* right;
        } node_t;

    TODO : SCHEME NEEDED + EXPLAIN WHICH NODE IS THE ROOT.
    + CHANGE THE CODE : word -> enWord, definition -> frWord.

    Your mission will be to implement the **insert** and the **delete** functions.

    - **Insert** function :

    For each node we know this : every key (*enWord*) in the node.left subpart is lower than the key of the node. Similarly, every key (*enWord*) in the node.right subpart is lower than the key of the node. We use the alphabetical order to check if one word is lower or higher than another one.

    - **Delete** function :

    Deleting a node in a tree like that might not be easy ! That's why I'll explain you how to proceed (you'll have to use this procedure in order to get the points).
    If the node we want to delete has 0 or only 1 child, it's quite easy, we only have to replace this node by his child (if there is one).
    When it comes to a node which has two children, it's harder. We first have to find the right subtree's leftmost child. In the example, if we want to suppress *XXX*, the leftmost node of the right subpart is *YYY*. Then, we can move *YYY* to *XXX* and replace *YYY* by his child (if it has one).

    SCHEME NEEDED for XXX and YYY.
environment: cpp
evaluate: best
groups: false
input_random: '0'
limits:
    memory: '100'
    time: '30'
    output: '2'
name: 'BST : Insert and Delete'
network_grading: false
problems:
    insert:
        type: code
        default: ''
        name: Insert function
        header: |-
            Write the body of the ``insert`` function. If you use subfonctions, write them in the box below with their signature and body.

            .. code-block:: c

                /*
                 * @bt: the binary tree, bt != NULL
                 * @enWord: the key of the new node, enWord != NULL
                 * @frWord: the value of the new node, frWord != NULL
                 * @return: 1 if the new node was inserted, 0 otherwise
                 */
                int insert(bt_t* bt, char* enWord, char* frWord);
        language: c
    other:
        language: c
        default: ''
        name: Subfunctions
        type: code
        optional: 'on'
        header: You can write your needed subfunctions here. Don't forget to write
            their signature and body.
    delete:
        header: |-
            Write the body of the ``delete`` function. We assume that each key (enWord) is unique. Delete the node using the technique explained in the problem statement.

            .. code-block:: c

                /*
                 * @bt: the binary tree, bt != NULL
                 * @enWord: the key of the node you want to delete, enWord != NULL
                 */
                void delete(bt_t* bt, char* enWord);
        name: Delete function
        type: code
        default: ''
        language: c
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
