accessible: false
author: Alexandre Gobeaux
context: |-
    To help you studying your english course, you've got the wonderful idea of creating a Binary Search Tree (BST). This will also help you to study for the LSINF1252 course! The key of each node will be the english word and the value will be the french word corresponding. Those are represented using an array of char.
    So let's define our 2 structures :

    .. code-block:: c

        typedef struct bt {
            struct node* root;
        } bt_t;

        typedef struct node {
            char* enWord;
            char* frWord;
            struct node* left;
            struct node* right;
        } node_t;

    TODO : SCHEME NEEDED + EXPLAIN WHICH NODE IS THE ROOT.
    + CHANGE THE CODE : word -> enWord, definition -> frWord.

    Your mission will be to implement the **insert**, the **leftmost node of right part** the **delete** functions.

    - **Insert** function :

    For each node we know this : every key (*enWord*) in the node.left subpart is lower than the key of the node. Similarly, every key (*enWord*) in the node.right subpart is lower than the key of the node. We use the alphabetical order to check if one word is lower or higher than another one.

    - **Leftmost node of right part** and **Delete** function :

    Deleting a node in a tree like that might not be easy ! That's why I'll explain you how to proceed (you'll have to use this procedure in order to get the points).
    If the node we want to delete has 0 or only 1 child, it's quite easy, we only have to replace this node by his child (if there is one).
    When it comes to a node which has two children, it's harder. We first have to implement a function that will find the leftmost node of the right subpart. In the example, if we want to suppress *XXX*, the leftmost node of the right subpart is *YYY*. Then, we can move *YYY* to XXX and replace *XXX* by his child (if it has one).

    SCHEME NEEDED for XXX and YYY.
environment: cpp
evaluate: best
groups: false
input_random: '0'
limits:
    time: '30'
    memory: '100'
    output: '2'
name: 'BST : Insert and Delete'
network_grading: false
problems:
    insert:
        type: code
        default: ''
        language: c
        name: Insert function
        header: |-
            Write the body of the ``insert`` function. If you use subfonctions, write them in the box below with their signature and body.

            .. code-block:: c

                /*
                 * Return 1 if the new node was inserted, 0 otherwise.
                 */
                int insert(bt_t* bt, char* enWord, char* frWord);
    other:
        name: Subfunctions
        header: You can write your needed subfunctions for the insert function.
        optional: 'on'
        default: ''
        type: code
        language: c
    rightsubtreesleftmostchild:
        type: code
        header: Write the body of the ``rightSubtreesLeftMostChild`` function.
        default: ''
        language: c
        name: Right subtree's left-most child
    delete:
        header: |-
            Write the body of the ``delete`` function. Using another fonction already written above would be helpful. We assume that each key (enWord) is unique.

            .. code-block:: c

                void delete(bt_t* bt, char* enWord);
        language: c
        default: ''
        type: code
        name: Delete function
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
