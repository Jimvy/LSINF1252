/student/student_code.c.tpl: |+
    #include <stdio.h>
    #include <stdlib.h>
    #include <errno.h>
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>
    #include <unistd.h>
    #include <string.h>

    int get(char* filename, int index){
    @    @q1@@
    }

    void set(char* filename, int index, int value){
    @    @q2@@
    }

/student/tests.c: |
    // CTester template

    #include <stdlib.h>
    #include "student_code.h"
    #include "CTester/CTester.h"

    int get_value_by_index(int i){
        return (i*i*(i/2))%20000;
    }

    /*
     * Generate a file named "file.txt".
     * The content is n int following the formula defined above.
     */
    void gen_file(int n){
        int fd = open("file.txt",O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR);
        if(fd == -1) {
            CU_FAIL("Error, can not initialise test file");
        }
        int array[n];
        int i = 0;
        for (i = 0; i < n; i++){
            array[i] = get_value_by_index(i);
            if (write(fd, (void *) &array[i], sizeof(int)) == -1){
                CU_FAIL("Error, can not initialise test file");
            }
        }
        if (close(fd) == -1)
            CU_FAIL("Error, can not initialise test file");
    }

    void test_get() {
        set_test_metadata("q1", _("Test with normal file"), 2);
        gen_file(1000);

        int should_count_read = 0;
        monitored.read = true;
        for(int i = 0; i < 1000; i+=50){
            should_count_read++;
            int ret = 0;

            SANDBOX_BEGIN;
            ret = get("file.txt", i);
            SANDBOX_END;

            if(ret != get_value_by_index(i)){
                push_info_msg(_("You do not return the correct value."));
                CU_FAIL();
            }
        }
        if(stats.read.called > should_count_read){
            set_tag("too_many_op");
            push_info_msg(_("You perform too many read()."));
            CU_FAIL();
        }
    }

    void test_set() {
        set_test_metadata("q2", _("Test with normal file"), 2);
        gen_file(1000);

        int should_count_write = 0;
        monitored.write = true;
        for(int i = 0; i < 1000; i+=50){
            should_count_write++;
            SANDBOX_BEGIN;
            set("file.txt", i, 2222+i);
            SANDBOX_END;
        }

        if(stats.write.called > should_count_write){
            set_tag("too_many_op");
            push_info_msg(_("You perform too many write()."));
            CU_FAIL();
        }

        int fd = open("file.txt", O_RDONLY);
        if(fd == -1) {
            CU_FAIL("Error, can not initialise test file");
        }
        for(int i = 0; i < 1000; i+=50){
            lseek(fd, (off_t) i*sizeof(int), SEEK_SET);
            int res;
            read(fd, (void *) &res, sizeof(int));
            if (res != 2222+i){
                push_info_msg(_("You do not set the correct value in the file."));
                CU_FAIL();
            }
        }
        close(fd);
    }

    int close_tag = 0;
    void test_close_q1(){
        set_test_metadata("q1", _("Test close"), 1);
        monitored.close = true;
        SANDBOX_BEGIN;
        get("file.txt", 0);
        SANDBOX_END;
        if (stats.close.called != 1){
            push_info_msg(_("You did not close the file."));
            CU_FAIL();
            close_tag++;
        }
    }

    void test_close_q2(){
        set_test_metadata("q2", _("Test close"), 1);
        monitored.close = true;
        SANDBOX_BEGIN;
        set("file.txt", 0,0);
        SANDBOX_END;
        if (stats.close.called != 1){
            push_info_msg(_("You did not close the file."));
            CU_FAIL();
            close_tag++;
        }
        if (close_tag == 0)
            set_tag("close");
    }

    void test_get_oob() {
        set_test_metadata("q1", _("Test get out of bound"), 2);
        gen_file(10);
        int ret = 0;

        SANDBOX_BEGIN;
        ret = get("file.txt", 200);
        SANDBOX_END;

        if(ret != -2){
            push_info_msg(_("You do not return -2 when index is bigger than the size of the array."));
            CU_FAIL();
        }
    }

    //TODO:
    //check if index id bigger than the file
    //check get fail.
    //check if other index are not modified

    int main(int argc, char** argv){
        BAN_FUNCS(system, set_tag);
        RUN(test_get, test_set, test_close_q1, test_close_q2, test_get_oob);
    }
accessible: true
author: Olivier Martin
context: |-
    Given a file containing a huge array of integers, you are asked to write a function to edit a value of the array and another to retrieve a value from the array.

    Since the array is huge, you can not load it entierly into memory. Consequently, you have to naviguate directly through the array in the file by using `lseek(2) <https://sites.uclouvain.be/SystInfo/manpages/man2/lseek.2.html>`_.

    You may want to use `fstat(2) <https://linux.die.net/man/2/fstat>`_ to get informations about the file.
environment: cpp
evaluate: best
groups: false
limits:
    output: '2'
    time: '30'
    memory: '50'
name: '[S5] Get and set on array in file'
network_grading: false
order: 26
problems:
    q1:
        name: ''
        type: code
        language: ''
        header: |-
            .. code-block:: c

                /*
                 * @pre filename != NULL, index >= 0
                 * @post return the integer at the index {index}
                 *       of the array in the file {filename}.
                 *       return -1 in case of error.
                 *       return -2 if index >= length of array.
                 */
                int get(char* filename, int index)
    q2:
        type: code
        language: ''
        name: ''
        header: |-
            .. code-block:: c

                /*
                 * @pre filename != NULL, index >= 0
                 * @post set the integer present in the file {filename}
                 *       at index {index} at value {value}
                 */
                void set(char* filename, int index, int value)
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags:
    '0':
        type: 0
        visible: true
        id: close
        name: Close
        description: This tag validate that your close are correctly performed.
    '1':
        id: open
        type: 0
        visible: true
        description: This tag validate you are able to open a file.
        name: Open
    '11':
        type: 1
        name: Out of bounds
        description: You try to read outside of the array.
        id: oob
        visible: true
    '2':
        id: too_many_op
        visible: true
        name: Too many read/write
        description: You call the read or write function more than necessary.
        type: 1
    '3':
        visible: true
        description: You use some banned functions.
        id: banned_funcs
        name: Banned functions
        type: 1
    '4':
        id: double_free
        name: Double free
        visible: true
        type: 1
        description: Your code produced a double free.
    '5':
        type: 1
        name: Failure handling
        id: failure_handling
        visible: true
        description: You do not manage failures during the copy properly.
    '6':
        id: sigfpe
        type: 1
        visible: true
        description: ''
        name: Floating Point Exception
    '7':
        name: Memory Exceeded
        id: memory
        visible: true
        description: ''
        type: 1
    '8':
        type: 1
        name: Not compile
        visible: true
        description: You code do not compile.
        id: not_compile
    '9':
        name: Timeout
        id: timeout
        type: 1
        description: Your code exceeds the maximum allowed time.
        visible: true
    '10':
        type: 2
        visible: true
        description: ''
        name: File
        id: ''
weight: 1.0
