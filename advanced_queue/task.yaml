accessible: false
author: Maxime Mawait & Nicolas Rybowski
context: |-
    You are asked to implement ``enqueue`` and ``dequeue`` functions of a `Queue` with simply circular linked list.

    Here there is a little explanation from
    `Wikipedia <https://en.wikipedia.org/wiki/Linked_list#Circularly_linked_vs._linearly_linked>`_ :

    "With a circular list, a pointer to the last node gives easy access also to the first node, by following one link. Thus, in applications that require access to both ends of the list (e.g., in the implementation of a queue), a circular structure allows one to handle the structure by a single pointer, instead of two."


    .. image:: https://upload.wikimedia.org/wikipedia/commons/d/df/Circularly-linked-list.svg

    Assume that the head of the queue is the leftmost node and that the tail of the queue is the rightmost node. In the previous example, the head and the tail are respectively `12` and `37`. So in this case, the only pointer you can use will point on the `37` node.

    Here are defined the structure you have to use to complete the task.

    .. code-block:: c

        typedef struct node{
          struct node* next;
          int value;
        } node_t;

        typedef struct queue{
          struct node* tail;
          int size;
        } queue_t  ;
environment: cpp
evaluate: best
groups: false
limits:
    output: '2'
    time: '30'
    memory: '100'
name: '[S4] Queue avanc√©e'
network_grading: false
order: 42
problems:
    enqueue:
        name: Enqueue
        type: code
        language: c
        header: |-
            .. code:: c

                /*
                *    Add @val value at the head of the @q queue
                *
                *    @val : the value to enqueue
                *   @q    : the queue to enqueue
                *
                *    @return 0 if no error, -1 else
                */
                int enqueue(queue_t* q, int val){
    dequeue:
        language: c
        name: Dequeue
        type: code
        header: |-
            *HINT* : Do not forget to free all the unused memory.

            .. code:: c

                /*
                *    Remove the node at the tail of the @q queue and returns the value
                *    @q : the queue to dequeue
                *
                *    @return : the value at the tail
                */
                int dequeue(queue_t* q){
stored_submissions: 0
submission_limit:
    amount: 5
    period: 1
tags:
    '0':
        name: Timeout
        type: 1
        id: timeout
        visible: true
        description: Your code exceeds the maximum allowed time.
    '1':
        description: ''
        visible: true
        id: sigsegv
        type: 1
        name: Segmentation Fault
    '2':
        visible: true
        type: 1
        id: not_compile
        name: Not compile
        description: You code does not compile.
    '3':
        id: memory
        visible: true
        description: ''
        type: 1
        name: Memory Exceeded
    '4':
        description: ''
        visible: true
        id: sigfpe
        name: Floating Point Exception
        type: 1
    '5':
        visible: true
        type: 1
        description: Your code produced a double free.
        name: Double free
        id: double_free
    '6':
        visible: true
        id: banned_funcs
        name: Banned functions
        type: 1
        description: You use some banned functions.
    '7':
        type: 2
        visible: true
        description: Task dealing with data structures and linked list
        name: Data structures
        id: ''
    '8':
        description: ''
        name: S4
        type: 2
        visible: true
        id: ''
weight: 1.0
