/run: |
    #!/bin/python3

    # Script d'interface entre INGInious et des tests unitaires écrits à l'aide de CUnit
    # Auteurs : Pablo Gonzalez Alvarez
    # Licence : GPLv3

    import subprocess, shlex, os, os.path.isfile
    from inginious import feedback, rst, input

    # Student final score
    score = 0

    # MATCH

    match = input.get_input("make_me_easy")
    if match != 'make make_me':
        feedback.set_problem_result("failed", "make_me_easy")
        feedback.set_problem_feedback("You didn't make it!", "make_me_easy")
    else:
        score += 25
        feedback.set_problem_result("success", "make_me_easy")
        feedback.set_problem_feedback("You made it!", "make_me_easy")

    # CODE

    # Switch working directory to student/
    os.chdir("student")

    # Fetch and save the student code into a file for compilation
    input.parse_template("Makefile.tpl", "Makefile")

    # Compilation
    p = subprocess.Popen(shlex.split("make"), stderr=subprocess.STDOUT, stdout=subprocess.PIPE)
    make_output = p.communicate()[0].decode('utf-8')
    # If compilation failed, exit with "failed" result
    if p.returncode:
        feedback.set_problem_feedback("The compilation of your code failed. The output message of the ``make`` command is:" + rst.get_codeblock('', make_output), "make_me_less_easy")
    else:
        score += 75
        feedback.set_problem_result("success", "make_me_less_easy")
        feedback.set_problem_feedback("Your code compiles.\n", "make_me_less_easy")

    # Remove source files
    subprocess.run("rm -rf *.c *.tpl *.h *.o", shell=True)

    # Check whether make builds the correct executable

    if( !os.path.isfile("./student/make_me"))
        feedback.set_problem_feedback("The compilation of your code failed. The output message of the ``make`` command is:", "make_me_less_easy")

    # Set score
    feedback.set_grade(score)
    feedback.set_global_result("success" if score >= 80 else "failed")
    feedback.set_global_feedback("Good job" if score >= 80 else "Try again")
accessible: true
author: Pablo Gonzalez Alvarez
context: |-
    *Estimated time: 20 minutes*

    ``make`` is a task runner for targets described in a `Makefile`. It is mostly used to control the compilation of an executable from source code. Thus, you can use it to automate the tidious task of compiling your c code, or even automate the compilation of a report made with LaTeX.

    ``make`` a new beginning
    ------------------------

    To give you a first taste, open up a *terminal* and type the following command: ``make``.

    ``make`` will great you with the following message:

    .. code-block::

        make: *** No targets specified and no makefile found.  Stop.

    So what happened? ``make`` first start to search in your *current directory* for a file called ``Makefile``. This file contains *instructions*, aka *rules*, that tell ``make`` what to do.  Since there are no such file, ``make`` stops almost instantly.

    ``make`` it simple
    ------------------

    Now write a simple hello world program, which you will save into a file called ``hello.c``. This programs will print the following on the standard output:

    .. code-block::

         Hello make

    Now, fire up your terminal, use ``cd path/to/hello/folder/`` to go to the directory which contains ``hello.c`` (`download hello.c <https://inginious.info.ucl.ac.be/course/LSINF1252-2018/s02_basics_make/hello.c>`_ to compare with what you did) and type: ``make hello``

    Now the ``make`` comes alive and tells you something like:

    .. code-block::

        cc     hello.c   -o hello

    Wow! What happened? When you typed ``make hello``, ``hello`` is what is called a **target**. A **target** is usually the name of a file that is generated by a program; examples of targets are executable or object files.

    Basically, ``make`` will search for a file named ``hello`` and detect from that file what programming language it uses. For most languages, ``make`` has some basic builtin recipes, called **implicit rules**, to compile it. Here the **recipe** is given in the above output.

    In that output:

    * ``cc`` stands for *C Compiler*;
    * ``hello.c`` the C program to be compiled;
    * ``-o hello`` an option to place the output of the compilation in the file ``hello``.

    Now if you type ``ls`` in your command line, you will see that a file ``hello`` appeared. This is the **executable** built by ``make`` from ``hello.c``. Now you can execute it and verify what is printed on the standard output.

    If you type again ``make hello`` in your command line, it will tell you:

    .. code-block::

        make: 'hello' is up to date.

    That is because ``make`` only builds the files that are changed. If ``hello`` is more recent than its source file ``hello.c``, ``make`` will skip the compilation process.

    To see this, modify ``hello.c`` to write the following on the standard output:

    .. code-block::

        Hello, make!

    Finally, run ``make hello`` again. Since ``hello.c`` is more recent than ``hello``, ``make`` will compile the source file again.

    Thats it, you made your first experiences with ``make``.

    Now I strongly recommend you read `sections 2.1 to 2.3. in the GNU make manual <https://www.gnu.org/software/make/manual/make.html#Introduction>`_. It will only take you 10 minutes (included in the above given estimated time) and will help you understand how to ``make`` magic happen.

    Once you read these 3 sections, let us practice a bit.

    To try the following questions locally, you can download a zip file of the questions folder `here <https://inginious.info.ucl.ac.be/course/LSINF1252-2018/s02_basics_make/make_me.zip>`_.

    ----

    References
    ----------

    * https://sites.uclouvain.be/SystInfo/notes/Outils/html/make.html
    * https://www.gnu.org/software/make/manual/
environment: cpp
evaluate: best
groups: false
limits:
    output: '2'
    memory: '100'
    time: '30'
name: '[S02] Makefile basics - REVIEWED'
network_grading: false
order: 22
problems:
    make_me_easy:
        type: match
        answer: make make_me
        name: Make me easy
        header: |-
            After typing ``ls`` in your terminal, you see the following folder structure:

            .. code-block:: console

                make_me.c       make_me.h

            You want to build an executable ``make_me`` from the above source thanks to ``make``. What do you type in the terminal to do that?

            **Hint:** you do not need to write a *Makefile*.
    make_me_less_easy:
        name: Make me less easy
        header: |-
            Suppose you cannot use what you did in the above question. Write a Makefile that compiles the above given code and builds an executable ``make_me``. You can reuse the ``Makefile`` given in the above given zip file.

            **Hint:** If you have no idea where to start, read `sections 2.1 to 2.3. in the GNU make manual <https://www.gnu.org/software/make/manual/make.html#Introduction>`_.
        type: code
        language: Makefile
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags:
    '0':
        name: make & Makefile
        id: make
        type: 0
        description: Tasks related to the make task runner for targets described in
            Makefile.
        visible: false
weight: 1.0
