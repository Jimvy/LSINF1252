/student/tests.c: |
    #include <stdlib.h>
    #include <stdio.h>
    #include <unistd.h>
    #include "student_code.h"
    #include "CTester/CTester.h"

    void test_success() {
        set_test_metadata("sleep_malloc", _("Malloc always success"), 1);

        void* ret = NULL;

        monitored.malloc = true;
        failures.malloc = FAIL_NEVER;
        SANDBOX_BEGIN;
        ret = sleep_malloc(16);
        SANDBOX_END;

        CU_ASSERT_PTR_NOT_NULL(ret);

        CU_ASSERT_TRUE(malloced(ret));

        CU_ASSERT_EQUAL(stats.malloc.called,1)
        if(stats.malloc.called > 1) push_info_msg(_("Why did you call malloc more then once?"));

        free(ret);
    }

    void test_fail_first() {
        set_test_metadata("sleep_malloc", _("Malloc fails first"), 1);

        void* ret = NULL;

        monitored.malloc = true;
        failures.malloc = FAIL_FIRST;
        monitored.sleep = true;
        failures.sleep = FAIL_ALWAYS;
        SANDBOX_BEGIN;
        ret = sleep_malloc(16);
        SANDBOX_END;

        CU_ASSERT_PTR_NOT_NULL(ret);

        CU_ASSERT_TRUE(malloced(ret));

        CU_ASSERT_EQUAL(stats.malloc.called,2)
        if(stats.malloc.called > 2) push_info_msg(_("Why did you call malloc more then once per loop?"));

        CU_ASSERT_EQUAL(stats.sleep.called,1)
        if(stats.sleep.called > 1) push_info_msg(_("Why did you call malloc more then once per loop?"));

        free(ret);
    }

    void test_fail_twice() {
        set_test_metadata("sleep_malloc", _("Malloc fails twice"), 1);

        void* ret = NULL;

        monitored.malloc = true;
        failures.malloc = FAIL_TWICE;
        monitored.sleep = true;
        failures.sleep = FAIL_ALWAYS;
        SANDBOX_BEGIN;
        ret = sleep_malloc(16);
        SANDBOX_END;

        CU_ASSERT_PTR_NOT_NULL(ret);

        CU_ASSERT_TRUE(malloced(ret));

        CU_ASSERT_EQUAL(stats.malloc.called,3)
        if(stats.malloc.called > 3) push_info_msg(_("Why did you call malloc more then once per loop?"));

        CU_ASSERT_EQUAL(stats.sleep.called,2)
        if(stats.sleep.called > 2) push_info_msg(_("Why did you call malloc more then once per loop?"));

        free(ret);
    }

    void test_fail_five() {
        set_test_metadata("sleep_malloc", _("Malloc fails five first times"), 1);

        void* ret = NULL;

        monitored.malloc = true;
        failures.malloc = 0x1f;
        monitored.sleep = true;
        failures.sleep = FAIL_ALWAYS;
        SANDBOX_BEGIN;
        ret = sleep_malloc(16);
        SANDBOX_END;

        CU_ASSERT_PTR_NOT_NULL(ret);

        CU_ASSERT_TRUE(malloced(ret));

        CU_ASSERT_EQUAL(stats.malloc.called,6)
        if(stats.malloc.called > 6) push_info_msg(_("Why did you call malloc more then once per loop?"));

        CU_ASSERT_EQUAL(stats.sleep.called,5)
        if(stats.sleep.called > 5) push_info_msg(_("Why did you call malloc more then once per loop?"));

        free(ret);
    }

    void test_fail_eight() {
        set_test_metadata("sleep_malloc", _("Malloc fails eight first times"), 1);

        void* ret = NULL;

        monitored.malloc = true;
        failures.malloc = 0xff;
        monitored.sleep = true;
        failures.sleep = FAIL_ALWAYS;
        SANDBOX_BEGIN;
        ret = sleep_malloc(16);
        SANDBOX_END;

        CU_ASSERT_PTR_NOT_NULL(ret);

        CU_ASSERT_TRUE(malloced(ret));

        CU_ASSERT_EQUAL(stats.malloc.called,9)
        if(stats.malloc.called > 9) push_info_msg(_("Why did you call malloc more then once per loop?"));

        CU_ASSERT_EQUAL(stats.sleep.called,8)
        if(stats.sleep.called > 8) push_info_msg(_("Why did you call malloc more then once per loop?"));

        free(ret);
    }

    void test_fail_ten() {
        set_test_metadata("sleep_malloc", _("Malloc fails ten first times"), 1);

        void* ret = (void*) 0x86;

        monitored.malloc = true;
        failures.malloc = 0x3ff;
        monitored.sleep = true;
        failures.sleep = FAIL_ALWAYS;
        SANDBOX_BEGIN;
        ret = sleep_malloc(16);
        SANDBOX_END;

        CU_ASSERT_PTR_NULL(ret);

        CU_ASSERT_EQUAL(stats.malloc.called,10)
        if(stats.malloc.called > 10) push_info_msg(_("Why did you call malloc more then once per loop?"));

        CU_ASSERT_EQUAL(stats.sleep.called,10)
        if(stats.sleep.called > 10) push_info_msg(_("Why did you call malloc more then once per loop?"));
    }

    void test_fail_always() {
        set_test_metadata("sleep_malloc", _("Malloc fails always"), 1);

        void* ret = (void*) 0x86;

        monitored.malloc = true;
        failures.malloc = FAIL_ALWAYS;
        monitored.sleep = true;
        failures.sleep = FAIL_ALWAYS;
        SANDBOX_BEGIN;
        ret = sleep_malloc(16);
        SANDBOX_END;

        CU_ASSERT_PTR_NULL(ret);

        CU_ASSERT_EQUAL(stats.malloc.called,10)
        if(stats.malloc.called > 10) push_info_msg(_("Why did you call malloc more then once per loop?"));

        CU_ASSERT_EQUAL(stats.sleep.called,10)
        if(stats.sleep.called > 10) push_info_msg(_("Why did you call malloc more then once per loop?"));
    }

    int main(int argc,char** argv)
    {
        BAN_FUNCS();
        RUN(test_success,test_fail_first,test_fail_twice,test_fail_five,test_fail_eight,test_fail_ten,test_fail_always);
    }
accessible: true
author: Mathieu Xhonneux & Maxime Mawait
context: |-
    The system call malloc may fail, for instance if the OS has no free memory remaining. In this case, it may be possible that some other processes free some memory after some time.

    In our program, instead of reporting an error immediately if no free memory is available, we will wait some time to see if the OS can free memory for us.
environment: pyjavacpp
evaluate: best
groups: false
limits:
    time: '30'
    output: '2'
    memory: '100'
name: '[S3] Sleepy memory'
network_grading: false
order: 14
problems:
    sleep_malloc:
        language: c
        name: Sleepy malloc
        type: code
        header: |-
            Write the body of the function *sleepy_malloc*.

            Hint : think about static variables.

            .. code-block:: c

                /* Wrapper to the malloc system call.
                 * If malloc fails, sleep for 5 seconds, and re-try.
                 * If malloc failed 10 times in a row, return NULL.
                 */
                void *sleepy_malloc(size_t s) {
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
tags: {}
weight: 1.0
